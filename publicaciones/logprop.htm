<div class="fichas_t">
    <h5><span class="material-icons">assignment</span> FICHA TÉCNICA</h5>
    <ul>
        <li><span class="subtitulos">Nombre</span>: logprop</li>
        <li><span class="subtitulos">Período de desarrollo</span>: diciembre 2021</li>
        <li><span class="subtitulos">Lenguaje</span>: Python</li>
        <li><span class="subtitulos">Categorías</span>: Módulo de Python / Calculadora lógica</li>
        <li><span class="subtitulos">Implementaciones destacadas</span>: POO, recursión, combinatoria, expresiones regulares, métodos "especiales" de Python</li>
        <li><a href="https://github.com/OldOwl83/logprop" target="_blank"><span class="material-icons">arrow_forward</span> Ir al código</a></li>
    </ul>
</div>

<h3>logprop</h3>

<h4>Presentación</h4>

 <p class="publicaciones">¡Mi primer Python! Este programa consiste, en esencia, en un pequeño módulo de clases capaz de construir objetos que representen fórmulas de la Lógica Proposicional a partir de su expresión en texto plano. Además, "logprop" ofrece las funcionalidades necesarias para combinarlos, descomponerlos e interpretarlos. También define un método para generar e imprimir por pantalla la correspondiente tabla de verdad (aunque tengo previsto completarlo en un futuro con más funcionalidades lógicas). Más allá del desafío técnico implicado en el desarrollo de estas clases (cualquiera sea el lenguaje utilizado), la escritura de este código me aportó un primer contacto con la sintaxis básica de Python, y una cierta familiarización con algunos de sus conceptos clave, como las <em>colecciones</em> de datos, los métodos "especiales" y su particular gestión del tipado.</p>

 <h4>Sobre los objetos de la clase "Formula"</h4>

  <p class="publicaciones">En principio, la tarea básica de este módulo es construir objetos de la clase "Formula", a partir de un <em>string</em> pasado por el cliente por parámetro al constructor. Sin embargo, "Formula" es sólo una clase general que contiene a los distintos tipos o subclases a los que puede pertenecer un tal objeto, dependiendo de la conectiva principal de la fórmula que representa. Por ahora, sólo se consideran la "conjunción", la "disyunción inclusiva", la "implicación material" y la "negación", así como las fórmulas carentes de conectivas, que serían las variables proposicionales y las fórmulas

      <span class="imagenes" id="salida_lp"><img src="imagenes/logprop/salida_lp.png" alt="">Ejemplo de salida de una tabla de verdad</span>

      encerradas por paréntesis redundantes (subclases F_CONJ, F_DISY, F_COND, F_NEG, F_ATOM y F_DUP, respectivamente). No obstante esta restricción, sería muy sencillo definir subclases para otras conectivas, como la "doble implicación" (bicondicional) o la "disyunción exclusiva". Cada uno de esos tipos, por lo demás, contiene, como propiedades, uno o dos objetos "Formula" -siempre especificados por una subclase- que representan las subfórmulas que afectan directamente a su valor de verdad. Por supuesto, éstos, a su vez, pueden contener otros objetos de la misma clase base, conformando una verdadera ramificación de objetos similar al <em>árbol constructivo</em> utilizado para analizar las oraciones de la Lógica Proposicional. Las ramas de este árbol terminan siempre en objetos del tipo "F_ATOM" (que representan las variables proposicionales), cuya propiedad distintiva no es otro objeto "Formula", sino un string que identidica su nombre (y que puede tener cualquier longitud, siempre que contenga únicamente caracteres alfabéticos).</p>
  <p class="publicaciones">Todos estos tipos comparten una serie de métodos destinados, sobre todo, a la gestión de sus relaciones, a las operaciones entre fórmulas, a sus niveles de profundidad respecto de una fórmula principal, a la asignación de sus valores de verdad y, especialmente, a la construcción de su tabla de verdad. Sin

      <span class="imagenes" id="llamada_lp"><img src="imagenes/logprop/llamada_lp.png" alt="">Ejemplo de llamada desde el programa cliente al constructor de los objetos "Formula"</span>
      embargo, no es recomendable que el cliente acceda a todos ellos de manera directa. Por eso, en la documentación se define una interfaz pública del módulo que, por ahora, sólo incluye el constructor, el método de generación e impresión de las tablas de verdad, y los operadores para componer, descomponer y manipular tales objetos.
      </p>
  <p class="publicaciones">Respecto de la construcción de los objetos 'Formula', adicionalmente, y por motivos que se explican con más detalle en "<span class="enlace_publ" onclick="Inserta_entrada('publicaciones/articulos/subclases_py.htm')">Construcción de un objeto de una subclase desde la clase base en Python</span>", se definió otra clase "FBF" (por <em>Fórmula Bien Formada</em>) que es con la que, en la superficie, interactúa el cliente. Esta clase es un simple instanciador de los objetos "Formula", cuyo único método sirve para analizar el <em>string</em> pasado y determinar a qué subclase de "Formula" pertenece el objeto a crear. De hecho, para el cliente, "FBF" es la única clase que existe, y cuando llama al método "Generar_tabla()" no sabe que, formalmente, el mismo no pertenece a "FBF". También se redefinió el método <code>__repr__</code> para que los objetos "Formula" fueran leídos como objetos "FBF", pronunciando el engaño al cliente pero devolviendo, por contrapartida, un constructor capaz de replicar cómodamente las instancias creadas.</p>

<h4>Implementaciones especiales</h4>

<ul class="publicaciones">
    <li><span class="subtitulos">Recursión</span>: La estructura arbórea implementada por la clase "Formula" me ha dado una gran ocasión para practicar la técnica de la recursión en la mayoría de sus métodos y funciones internas. Se aplican dos tipos de recursión. El primero consiste en realizar determinada operación sobre el objeto que llama a la función del caso, y luego -o antes- volver a llamar a la misma para las subfórmulas que componen la fórmula previa. Dentro de esta clasificación estarían el método "Imprimir_árbol()" y las funciones

        <span class="imagenes" id="recursion_lp"><img src="imagenes/logprop/recursion_lp.png" alt="">La subclase F_COND, con sus funciones recursivas</span>

        "Registro_formulas()", "Asignar_valores()" y "Registrar_valores_fila()". La segunda aplicación de la recursión, que a mi modo de ver sería la recursión en sentido estricto, se establece cuando la operación que se intenta realizar sobre el objeto que llama a la función depende de la previa realización de la misma acción sobre los objetos que componen a ese objeto. En tal caso, la función devuelve un valor que es requerido por las instancias superiores, y que va transmitiéndose a través de las autollamadas encadenadas de la propia función. Este funcionamiento lo desarrollan los métodos "Tomar_valor()" y "__str__()", y la función "Devolver_profundidad()". En todos los casos, la recursión finaliza con la llamada para los objetos tipo F_ATOM (el "caso base"), que devuelven los "valores absolutos" <em>en relación a los cuales</em> se definirán los del resto del árbol. Estos valores son, primordialmente, los valores de verdad, el nivel de profundidad y el texto plano (string) con que se representan a las fórmulas por pantalla.</li>
    <li><span class="subtitulos">Combinatoria de los valores de verdad para las variables proposicionales</span>: Probablemente, este punto no sería digno de mención, si no fuera porque <em>a priori</em> no sabía cómo iba a implementarlo, aunque la solución acabó siendo bastante sencilla. Lo cierto es que la cantidad de filas que componen una tabla de verdad depende de la cantidad de combinaciones posibles de los valores de verdad de sus variables proposicionales (VP). Este cálculo no representa ninguna dificultad (cantidad de valores^cantidad de variables). La dificultad radicaba en diseñar un algoritmo lo más sencillo posible que garantizara el despliegue de esas diversas combinaciones a lo largo de las filas. Opté por dividir las filas en mitades para la primera VP, en cuartos para la segunda, en octavos para la tercera, y así, para poder altarnar sus valores de verdad de acuerdo a los bloques obtenidos. Para ello, en un bucle <em>for</em> de tantos ciclos como VP tenga la fórmula, declaré una variable "divisor" para almacenar la cantidad de bloques necesarios para cada variable, que tiene "2" como valor inicial y va duplicándose en cada ciclo. Otra variable "periodo" almacena el período de variación del valor para cada VP, según la división de las filas totales por el divisor (2 ** len(VP) / divisor). Y por último, de acuerdo al módulo 2 del número de cada fila dividida por el período ((fila//periodo) % 2), asignaba <code>True</code> si daba 0, y <code>False</code> si daba 1. ¡Violà!</li>
    <li><span class="subtitulos">Métodos "mágicos"</span>: Un aspecto interesante de Python que descubrí en esta oportunidad, y en el cual hice mis primeras armas. Si bien muchos de estos métodos considerados "especiales" emulan funcionalidades que pueden encontrarse en otros lenguajes, como constructores de objetos y sobrecarga

        <span class="imagenes" id="operaciones_lp"><img src="imagenes/logprop/operaciones_lp.png" alt="">Algunas de las operaciones que pueden hacerse con los objetos "Formula"</span>

        de operadores, me llamó la atención la cantidad que hay (es difícil encontrar la lista completa) y cuánto facilitan la manipulación de muchos aspectos de los objetos instanciados. Para el caso de "logprop", hasta el momento su mayor provecho se obtuvo en la posibilidad de componer y descomponer los objetos "Formula", apelando a los índices entre corchetes para acceder y modificar a las subfórmulas, a los operadores "*" y "+" para devolver la conjunción y la disyunción de dos objetos, y a "-" para eliminar algún miembro de una fórmula bimembre. Finalmente, con lo que me estube peleando largo y tendido, fue el método <code>__new__</code>, que controla el momento de instanciación de los objetos, previo a su construcción/inicialización. Me explayo más sobre este punto en el artículo "<span class="enlace_publ" onclick="Inserta_entrada('publicaciones/articulos/subclases_py.htm')">Construcción de un objeto de una subclase desde la clase base en Python</span>".</li>
    <li><span class="subtitulos">Expresiones regulares</span>: Precisamente, es el método <code>__new__</code> de la clase "FBF" el encargado de decidir cuál va a ser el constructor de cada subfórmula. Para ello, cuenta con un método propio para analizar las fórmulas expresadas en texto plano (string), validar su corrección y dividirlas en términos de tipo/conectiva principal y subfórmulas que la componen. En una primera versión, este trabajo lo hacía de manera bastante manual a través de bucles y examinando el string caracter por caracter. Esa primera versión del método se extendía sobre largas 130 líneas de código (comentarios incluidos), y sólo recurría a expresiones regulares para detectar cadenas alfabéticas. En una segunda versión, que mantenía la misma estructura que la anterior pero apelaba a las expresiones regulares para detectar otros tipos de estructura (por ejemplo, "(!?\([A-Za-z()&amp|\->!]+\))"), logré acortar esa suma a 90. Sin embargo, el mayor problema de esta solución radicaba en que combinaba

        <span class="imagenes" id="regex_lp"><img src="imagenes/logprop/regex_lp.png" alt="">Algunas expresiones regulares diseñadas</span>

        expresiones regulares establecidas mediante literales con cadenas almacenadas en variables, lo que volvía muy rebuscado el escape de caracteres especiales. Finalmente, intenté encarar todo el análisis de las fórmulas mediante expresiones regulares literales, modificando la estructura misma del algoritmo original. La versión definitiva ocupa 65 líneas, pero más allá de su brevedad, me parece mucho más legible. En todo caso, en esta versión tampoco fue posible dejar todo el análisis en manos de las expresiones regulares, ya que las mismas no permiten (o no supe hacerlo) controlar la consistencia entre los paréntesis izquierdos y derechos que estructuran la sintaxis de las fórmulas de la Lógica Proposicional, para lo cual, fue necesario conservar una función <em>ad hoc</em> de la versión original, aunque bastante simplificada.</li>
</ul>
