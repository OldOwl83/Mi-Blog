<script> 

    window.location.assign(`https://hellocode-blog.net?path=${ window.location.pathname }`);
    
</script>

<div class="fichas_t">
    <h5><span class="material-icons">assignment</span> FICHA TÉCNICA</h5>
    <ul>
        <li><span class="subtitulos">Nombre</span>: Hello Code!</li>
        <li><span class="subtitulos">Período de desarrollo</span>: diciembre 2021</li>
        <li><span class="subtitulos">Stack</span>: HTML5 - PHP</li>
        <li><span class="subtitulos">Categoría</span>: Sitio Web</li>
        <li><span class="subtitulos">Implementaciones destacadas</span>: AJAX, <em>JS History API</em>, <em>server side</em>, menúes de navegación, <em>responsive design</em></li>
    </ul>
</div>

<h3>Este blog</h3>

<h4>Presentación</h4>

 <p class="publicaciones">Espero que este blog hable por sí mismo. No es más que lo que se ve: un tablón donde presentar algunos comentarios sobre mis trabajos y especulaciones en programación, intentando hacer foco en los aprendizajes realizados, las dificultades encontradas y las soluciones alcanzadas. En todo caso, se trata del primer sitio web que instalé en un servidor remoto, de modo que, más allá de aciertos y errores, es para mí una gran fuente de experiencias y aprendizajes.</p>

<h4>Implementaciones especiales</h4>

<ul class="publicaciones">
    <li>
        <p><span class="subtitulos">AJAX</span>: Todo lo que sucede dentro de este sitio, se despliega en un mismo documento HTML. Los únicos elementos permanentes son el &ltheader&gt, los menúes de navegación y un contenedor principal en el &ltmain&gt donde se cargan todos los artículos y secciones. Éstos son recuperados del servidor mediante un objeto XMLHttpRequest() e insertados
    
            <span class="imagenes" id="logo_blog"><img src="imagenes/logo.png" alt="">Logo distintivo del sitio</span>
    
        en el contenedor principal con JS (función 'Inserta_entrada'). De este sencillo modo, el sitio funciona como una <em>Single Page Application</em> sin necesidad de recurrir a <em>frameworks</em> o librerías especiales. Pero ello implicó un problema adicional, relativo a su navegación interna, ya que todas las páginas se cargaban sobre una misma URL; lo que me obligó a implementar un sistema casero de <em>routing</em>, que se comenta en el siguiente párrafo.</p>
    </li>
    <li>
        <p><span class="subtitulos"><em>History API</em> y <em>routing</em></span>: El funcionamiento descrito en el punto anterior implicaba dos problemas importantes. En primer lugar, las rutas correspondientes a cada sección no se cargaban en la URL del navegador, por lo que no quedaban registradas en su historial ni eran fácilmente accesibles para el usuario. En segundo lugar, si se pretendía acceder directamente a las mismas desde un enlace externo, no se cargaban de la manera prevista, dentro del DOM generado por el <em>index</em>.</p>
        <p>Para resolver el primer punto, hice que la función "Inserta_entrada()", al cargar una nueva sección al DOM, modificara la URL mediante el método <em>history.pushState()</em>, asociándole al estado la misma ruta particular de la sección cargada. En paralelo, puse al objeto <em>window</em> a la escucha del evento <em>popstate</em>, de modo que, cada vez que se volviera sobre las rutas modificadas, se pudiera cargar la sección correspondiente.</p>
        <p>En cambio, para facilitar su enlace externo, añadí al comienzo de cada sección un breve <em>script</em> JS que redirige a la página principal, pasando su propia ruta como parámetro en la URL. Entonces, cada vez que se carga, el <em>window</em> evalúa si se pasó alguna ruta por la URL para cargar la sección correspondiente; y si no se reciben rutas, se carga la portada inicial.</p>
    </li>
        
    <li>
        <p><span class="subtitulos"><em>Server side</em></span>: Este sitio tiene todavía muy poco PHP, y está todo concentrado en la sección de "Contacto". Los mensajes enviados por formulario son almacenados en un archivo de texto plano en el servidor, y se remite un mail a una casilla personal notificando el ingreso de los mismos. Está previsto en un futuro próximo implementar un espacio de comentarios particular para cada publicación, que dejará visibles los mensajes para todos los visitantes. Para usos más sofisticados de PHP, remito a la entrada correspondiente al sistema de gestión de Bibliotecas "Catalón".</p>
    </li>
    <li>
        <p><span class="subtitulos">Menúes de navegación</span>:
    
        <span class="imagenes" id="objetos_entr"><img src="imagenes/MiBlog/objetos_entr_miblog.png" alt="">Detalle del vector de entradas</span>
    
        Entre los elementos estables de la página están sus menúes de navegación. Uno de ellos, el que se aloja horizontalmente en la parte superior, es totalmente ordinario. El otro, en cambio, se ajusta dinámicamente al criterio de clasificación de las publicaciones seleccionado por el usuario. El despliegue de su contenido está mayormente automatizado: el programador simplemente carga en un vector de objetos literales las etiquetas correspondientes a cada publicación. El algoritmo se encarga de leer esos datos y almacenar en un objeto JS tipo <em>set</em> los        
    
        <span class="imagenes" id="responsive_mb"><img src="imagenes/MiBlog/responsive_miblog.png" alt="">Vista del blog en una pantalla menor a 840px</span>
    
        diversos valores ingresados, evitando la duplicación de etiquetas. Luego, en una iteración de ese <em>set</em> se van desplegando las entradas correspondientes en el &ltnav&gt del documento HTML.</p>
    </li>
    <li>
        <p><span class="subtitulos"><em>Responsive design</em></span>: Intenté que el diseño de la página se adapte automáticamente a los distintos anchos del <em>viewport</em> de la mejor manera posible, sin recurrir a librerías especiales como <em>Bootstrap</em>, ni a técnicas estandarizadas como <em>grid-view</em>. El método básico consistió en definir el valor de las propiedades <em>width</em> y <em>font-size</em> mediante unidades relativas (principalmente con "%") para la mayoría de los elementos del DOM. Lo mismo se hizo con algunos márgenes significativos. Adicionalmente, se definieron <em>media queries</em> para variar el tamaño de la fuente para el &ltbody&gt, ya que de él depende el tamaño relativo de la fuente del resto de los elementos. Además, escribí una hoja de estilos especial para pantallas menores a 840 píxeles de ancho (pensada para móviles), en la que principalmente se fija la posición de ambos menúes de navegación en la parte superior del tablón central, ocupando todo el ancho de la página. También se establece, por regla general, el ancho de las imágenes al 100%, para que puedan apreciarse y no se dejen rodear por columnas de texto demasiado pequeñas.</p>
    </li>
</ul>
